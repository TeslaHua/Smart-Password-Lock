#include"DS1302.h"

uchar second=0,minute=0,hour=0;  //需要转换的时分秒
uchar day=0,month=0,year=0;	   //需要转换的年月日
uchar temp=0;           //直接读到的DS1302的数值，还要做转换

/*******************************************************************************
* 函 数 名         : Delay(uchar z)
* 函数功能		   : 延时
* 输    入         : uchar z
* 输    出         : 无
*******************************************************************************/
void Delay1302(uint z)
{
	uint a,b;
	for(a=z;a>0;a--)
		for(b=110;b>0;b--);
}


/*******************************************************************************
* 函 数 名         : Ds1302init()
* 函数功能		   : Ds1302初始化
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void Ds1302init()			//初始化函数
{	
	Write1302(0x8e,0x00);		//取消写保护		
    Write1302(0x80,((30/10)<<4|(30%10)));    //1302上的时间初始化，并且将十进制数转换成BCD码
	Write1302(0x82,((55/10)<<4|(55%10)));
    Write1302(0x84,((19/10)<<4|(19%10)));
    Write1302(0x86,((19/10)<<4|(19%10)));
    Write1302(0x88,((12/10)<<4|(12%10)));
    Write1302(0x8c,((15/10)<<4|(15%10)));    
	Write1302(0x80,0x00);       //打开1302 的震荡，使其走字
	Write1302(0x8e,0x80);	    //写入写保护
}


/*******************************************************************************
* 函 数 名         :  Write1602sfm
* 函数功能		   : 在1602上面刷新DS1302的时分秒
* 输    入         : add,液晶显示初始位置，data日期数据
* 输    出         : 无
*******************************************************************************/
void Write1602sfm(uchar add,char date)		//1602刷新时分秒
{
	char shi,ge;
	shi=date/10;
	ge=date%10;
	lcdwritecom(0x80+0x40+add);
	lcdwritedate(0x30+shi);
	lcdwritedate(0x30+ge);
}

/*******************************************************************************
* 函 数 名         : Write1602nyr
* 函数功能		   : 在1602上面刷新DS1302的年月日
* 输    入         : add,液晶显示初始位置，data日期数据
* 输    出         : 无
*******************************************************************************/
void Write1602nyr(uchar add,char date)		//1602刷新年月日
{
	char shi,ge;
	shi=date/10;
	ge=date%10;
	lcdwritecom(0x80+add+3);
	lcdwritedate(0x30+shi);
	lcdwritedate(0x30+ge);
}


/*******************************************************************************
* 函 数 名         : Write1302
* 函数功能		   : 往ds1302里面写数据
* 输    入         : add,8位地址命令，data为8位数据
* 输    出         : 无
*******************************************************************************/
void Write1302(uchar addr, uchar dat)
{
	uchar n;
	RST=0;
	_nop_();
	DSIO=0;//先将SCLK置低电平。
	_nop_();
	RST=1; //然后将RST(CE)置高电平。
	_nop_();
	for(n=0; n<8; n++)//开始传送八位地址命令
	{
		DSIO=addr&0x01;//数据从低位开始传送
		addr >>= 1;
		SCLK = 1;//数据在上升沿时，DS1302读取数据
		_nop_();
		SCLK = 0;
		_nop_();
	}
	for (n=0; n<8; n++)//写入8位数据
	{
		DSIO= dat & 0x01;
		dat >>= 1;
		SCLK = 1;//数据在上升沿时，DS1302读取数据
		_nop_();
		SCLK = 0;
		_nop_();	
	}	
		 
	RST = 0;//传送数据结束
	_nop_();
}


/*******************************************************************************
* 函 数 名         : Read1302
* 函数功能		   : 从ds1302里面读出8位数据
* 输    入         : add,8位地址命令
* 输    出         : dat,8位的数据
*******************************************************************************/
uchar Read1302(uchar addr)
{
	uchar n,dat,dat1;
	RST = 0;
	_nop_();


	SCLK = 0;//先将SCLK置低电平。
	_nop_();
	RST = 1;//然后将RST(CE)置高电平。
	_nop_();


	for(n=0; n<8; n++)//开始传送八位地址命令
	{
		DSIO = addr & 0x01;//数据从低位开始传送
		addr >>= 1;
		SCLK = 1;//数据在上升沿时，DS1302读取数据
		_nop_();
		SCLK = 0;//DS1302下降沿时，放置数据
		_nop_();
	}
	_nop_();
	for(n=0; n<8; n++)//读取8位数据
	{
		dat1 = DSIO;//从最低位开始接收
		dat = (dat>>1) | (dat1<<7);
		SCLK = 1;
		_nop_();
		SCLK = 0;//DS1302下降沿时，放置数据
		_nop_();
	}


	RST = 0;
	_nop_();	//以下为DS1302复位的稳定时间,必须的。
	SCLK = 1;
	_nop_();
	DSIO = 0;
	_nop_();
	DSIO = 1;
	_nop_();
	return dat;	
}


/*******************************************************************************
* 函 数 名         : Transformation()
* 函数功能		   : 把从ds1302里面读出8位数据转换成供1602显示的数据
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void Transformation()			//把从DS1302中读取的数装换为需要的数给LCD1602显示
{
	temp=Read1302(0x81);
	second=((temp&0x70)>>4)*10+(temp&0x0f);		//将BCD码换成十进制个给1602显示
	Write1602sfm(10,second);
	temp=Read1302(0x83);
	minute=((temp&0x70)>>4)*10+(temp&0x0f);
	Write1602sfm(7,minute);
	temp=Read1302(0x85);
	hour=((temp&0x70)>>4)*10+(temp&0x0f);
	Write1602sfm(4,hour);
	temp=Read1302(0x87);
	day=((temp&0x70)>>4)*10+(temp&0x0f);
	Write1602nyr(8,day);
	temp=Read1302(0x89);
	month=((temp&0x70)>>4)*10+(temp&0x0f);
	Write1602nyr(5,month);
	temp=Read1302(0x8d);
	year=((temp&0xf0)>>4)*10+(temp&0x0f);
	Write1602nyr(2,year);
}


